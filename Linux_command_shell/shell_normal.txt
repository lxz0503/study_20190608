1.how to configure tftp on ubuntu
https://www.iteye.com/blog/xouou-2139332

安装xinetd：
sudo apt-get install xinetd

安装tftp和tftpd：
sudo apt-get install tftp tftpd

 或者安装tftp的增强版本tftp-hpa, tftpd-hpa (推荐)
sudo apt-get install tftp-hpa tftpd-hpa
tftp-hpa 这个是客户端
tftpd-hpa 这个是服务端

ps -ef |grep tftp          能看到tftpd－hpa进程
netstat -a | grep tftp 成功显示正在运行
不行的话试试/etc/init.d/xinetd start

sudo service tftpd-hpa restart -----sometimes you need to restart

=============for my environment========
apt-get install tftpd-hpa

apt-get install xinetd

enter /etc/xinetd.d and touch tftp, chmod -R 777 tftp

modify the content in tftp:
service tftp

    {

       disable = no

       socket_type = dgram

       protocol = udp

       wait = yes

       user = root

       server = /usr/sbin/in.tftpd

       server_args = -s /tftpboot -c

       per_source = 11

       cps = 100 2

       flags =IPv4

    }


and then: sudo service tftpd-hpa restart
sudo /etc/init.d/xinetd reload

sudo /etc/init.d/xinetd restart

mkdir Cp /tftpboot

sudo chmod -R 777 /tftpboot
=================================================================

echo要支持同C语言一样的\转义功能，只需要加上参数-e，如下所示：
shell echo打印换行的方法

[~]#echo -e "Hello world.\nHello sea"
Hello world.
Hello sea

grep -n 'beijing' xiaozhan.txt   输出所在行号
grep bash$ xiaozhan.txt    查找以bash为结尾的行

vi +20 xiaozhan.txt  可以直接跳转到所在行

cat xiaozhan.txt | grep ^# -v 表示过滤掉以#开始的行

grep -v ^$  过滤掉空行

cat xiaozhan.txt | grep ^# -v | grep ^$ -v
也可以这样操作: cat xiaozhan.txt | grep -Ev  '^(#|$)'

实际当中要把文件修改后保存到另外一个文件的方法：
cat xiaozhan.txt | grep -Ev  '^(#|$)' > xiaozhan.tmp; cat xiaozhan.tmp > xiaozhan_2.txt; rm -f xiaozhan.tmp

1. cat test.txt | sed 's/^/#/g' > new.txt --------用#替代每行的开头，即把#加在每行开头

Li xiaozhan@DESKTOP-JFCIJJF ~
$ cat new.txt
#ssss
#aaaaa
#ddddd
#ffffff
#--------------------空行
#cccccc
#vvvvvv

sed -i 就是直接对文本文件进行操作的,会直接修改文件的内容

cat xiaozhan.txt | sed  '21,24 s/beijing/captical/'    不会修改源文件，只是在内存里修改

去掉 “行首” 带“@”的首字母@

sed -i '/^#/d' xiaozhan.txt
删除空行   sed -i '/^$/d' xiaozhan.txt

sed  -i '/Ethernet/r myfile' test  匹配Ethernet的行，读进来另一个文件myfile的内容，读进来的文件的内容会插入到匹配Ethernet的行后

如果要执行多个sed命令可以用sed -e
sed -e '/^#/d' -e '/^#/d' xiaozhan.txt


sed -i 's/^@//' file

sed -i 's/^#//' file---------去掉python注释的时候用
特定字符串的删除
sed -i '5,6 s/^#//g' sub.py      指定删除第5到第6行的开头的#


sed -i '/字符串/d' file----删除所有符合条件的行

如果是不规则的文件，可以基于关键字来替换,看下面的例子
表示从遇到aaa那行开始，直到遇见ttt那行，把beijing都替换为capital
如果遇到aaa后，下面的行没有遇见ttt，但是遇见beijing，依然替换

cat xiaozhan.txt | sed '/aaa/,/ttt/ s/beijing/capital/'

# 可以把sed规则写在一个文件里  myrule.txt
/^#/d
/^$/d
s/shanghai/finace/i
/aaa/,/ttt/ s/beijing/capital/

然后执行sed -f myrule.txt < xiaozhan_1.txt     不会修改源文件

重定向到另外一个文件 sed -f myrule.txt < xiaozhan_1.txt > test.txt



cat a b c > file -----把文件a,b,c的内容合并到file里，同时也创建了文件file

2.Li xiaozhan@DESKTOP-JFCIJJF ~
$ cat test.txt | sed '/^$/d' > new.txt ------------删除空行，保存新文件到new.txt 

Li xiaozhan@DESKTOP-JFCIJJF ~
$ cat new.txt
ssss
aaaaa
ddddd
ffffff
cccccc
vvvvvv
3. sort -u 能够移除重复的行
  sort | uniq -c    可以统计重复的次数

ps | awk '{print $8}' | sort | uniq -c
      2 /usr/bin/bash
      1 /usr/bin/mintty
      1 /usr/bin/ps
      1 COMMAND

4.Li xiaozhan@DESKTOP-JFCIJJF ~
$ tar -czvf  file.tar.gz  file1  file2 ----tar包，压缩成tar.gz格式


tar -xzvf  file.tar.gz  ---------解压缩tar.gz包


5.$ gunzip  new.tar.gz

Li xiaozhan@DESKTOP-JFCIJJF ~
$ ls
aaa  bbbbb  new.tar  old.txt  rename.txt  test.sh  test.txt
                                                                                                                                                   
6. grep -rI "xiaozhan" ./  (在当前目录递归查找所有包含xiaozhan字样的文本)

7. find . -name "*xiaozhan*“ -print (在当前目录查找包含xiaozhan字样的目录)

搜索最近七天内被访问过的所有文件
find . -type f -atime -7
find . -type d -atime -7 ------搜索目录

find . -type f -size +10k ---搜索大于10K的文件
find . -type d -size +10k-----搜索大于10K的目录

find . -type f -name "*.txt" -delete  -----删除当前目录下所有txt后缀的文件

或者rm -rf $(find . -type f -name "*.txt")
或者find . -type f -name "*.txt" -ok rm {} \;

{} 用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名，也就是说{}代表着匹配的所有文件名

将30天前的.log文件移动到old目录中
find . -type f -mtime +30 -name "*.log" -exec cp {} old \;

8. vi test.txt
 :set number ----显示行号
 :10 按回车 ---------表示直接跳转到第10行
 
9：vi test.txt
:set number
:10,20y ----表示复制第10到第20行
在需要粘贴的地方输入P，表示粘贴到此处

:10,20s/#/    /g -----用4个空格替换开头的#

:10,20s/^/    /g----在每行行首添加4个空格


二、利用正则表达式删除代码段每行的行号

:%s/^\s*[0-9]*\s*//g

删除多行行尾指定字符串 :%s/#$//g

:%s/^[0-9][0-9]* // 去掉行首的所有数字字符。
:%s/ */ /g 把一个或者多个空格替换为一个空格。
:g/^\s*$/d " 删除只有空白的行


其中，^表示行首，$表示行尾，\s表示空格，[0-9]表示0~9的数字，*表示0或多个，%s/^\s*[0-9]*\s*//gc的意思是将每行以0或多个空格开始中间包含0或多个数字并以0或多个空格结束的字符串替换为空。


10. scp -r a.txt /home/windriver/ ----拷贝文件
    scp -r a.txt windriver@128.224.166.46:/home/windriver/ ---拷贝文件到此目录下面
	scp -r a.txt windriver@128.224.166.46:/home/windriver/a.txt.bak ---拷贝文件到此目录下面，并修改名字

11. ssh windriver@128.224.166.46  ---ssh登陆某台服务器

12. telnet 192.168.195.2 2323 ----telnet登陆某台虚拟机，端口号是2323

13. ftp 128.224.167.168 -----ftp登陆某台服务器

14. ls -l >> log.txt (把ls -l的命令输出结果追加到文件log.txt)  ---相当于ls -l | tee log.txt

15. run command & -----后台操作

./test.sh > res2.log 2>&1 ----标准输出，标准错误  这里&相当于等效于标准输出。 

 ./test.sh 2>&1 | tee  res2.log   ------可以把log打印到屏幕上同时也保存到文件里

# 多条命令放一行执行，中间用分号来隔开即可
# ls -l 2> err.log 
# ls /etc/aa /tc/b &> all.log   保存所有的信息,重定向所有输出
#（ls -al;cat /etc/passwd）| less  组合两条命令的输出

Linux：cut命令详解
1.例如有一个学生报表信息，包含No、Name、Mark、Percent：

复制代码
cat test.txt

No Name Mark Percent
01 tom 69 91
02 jack 71 87
03 alex 68 98

cut -f 2,3 test.txt
结果：
Name Mark
tom 69
jack 71
alex 68
---------------


复制代码
cat test2.txt

No;Name;Mark;Percent
01;tom;69;91
02;jack;71;87
03;alex;68;98

使用 -d 选项指定字段分隔符,默认分隔符是 TAB键，
如果实际文本不是tab键，必须用-d 来指明分隔符，例如空格分隔的话就是用" "
cut  -d ; -f 2 test2.txt
结果：
Name
tom
jack
alex

下面的cut命令可以切分出ip地址

-f2  ---it can show the second column(start from 1 column)
# ifconfig eth0 | grep "inet addr:" | cut -d : -f 2 | cut -d " " -f 1

windriver@PEK-QCAO1-D2:~/test_rsync$ ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{print $1}'
128.224.159.79
or use below line:
ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{print "{\"HOSTIP\": \""$1"\"}"}'
{"HOSTIP": "128.224.159.79"}

# 利用windows下安装的git来练习linux shell命令
# 用下面的方法可以编辑一个文本，把里面的多行内容输出到另外一个文件
cat << ENDOFLINE >> xiaozhan.txt
>beijing 100000
>shangahi 20000
>ENDOFLINE       表示结束符
------------------------------------
#  只查看文本的特定行
cat xiaozhan.txt | head      看前10行   或者直接用  head xiaozhan.txt
cat xiaozhan.txt | tail      看后10行               tail xiaozhan.txt
cat xiaozhan.txt | head -n 3  前3行                  head -n 3 xiaozhan.txt
cat xiaozhan.txt | tail -n 3   后3行                 tail -n 3 xiaozhan.txt

===========================================
vi 多窗口编辑命令： vi -o file1 file2

纵向显示多个文件，窗口间切快捷键：ctrl+w（需要按两次w）

保存并退出全部窗口：wqa

退出全部窗口：qa

------------------------------------------------------------------
vim -O file1 file2 横向显示  是大写的字母O

窗口间切快捷键：ctrl+w（需要按两次w）

保存并退出全部窗口：wqa

退出全部窗口：qa
------------------------------------------------------------------
切换到root的身份的命令即为：su -root或是直接 su -
通过命令exit或logout，或者是快捷键Cry+D即可返回原用户身份
for example:
windriver@PEK-QCAO1-D2:~/ANVL/xiaozhan$ su -
Password:
root@PEK-QCAO1-D2:~# exit
logout
windriver@PEK-QCAO1-D2:~/ANVL/xiaozhan$
------------------------------------------------------------------
Linux下环境变量设置的三种方法：

$PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接。

如想将一个路径加入到$PATH中，可以像下面这样做：

1、控制台中设置，不赞成这种方式，因为他只对当前的shell 起作用，换一个shell设置就无效了：

$PATH=$PATH:/NEW_PATH (关闭shell Path会还原为原来的path)

2、修改 /etc/profile 文件，如果你的计算机仅仅作为开发使用时推存使用这种方法，
因为所有用户的shell都有权使用这个环境变量，可能会给系统带来安全性问题。这里是针对所有的用户的，所有的shell

在/etc/profile的最下面添加： export PATH=$PATH:/NEW_PATH

3、修改bashrc文件，这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，
这里是针对某一特定的用户，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的 .bashrc文件就可以了。
---------------------------------------

linux中如何设置能使一个脚本在任意目录下都可直接运行，不要非到这个脚本所在目录下运行？
方法如下3种:    其实安装python或者tcl等后都是这么做的



1.把这个脚本所在目录加入PATH环境变量中。for instance:
PATH=$PATH:/etc/apache/bin
使用这种方法,只对当前会话有效，也就是说每当登出或注销系统以后，PATH 设置就会失效
for example:
windriver@PEK-QCAO1-D2:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
windriver@PEK-QCAO1-D2:~$ PATH=$PATH:/home/windriver      # add new path， export PATH=$PATH:/home/windriver
windriver@PEK-QCAO1-D2:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/windriver
windriver@PEK-QCAO1-D2:~/xiaozhan$ cd pexpect-4.6.0/
windriver@PEK-QCAO1-D2:~/xiaozhan/pexpect-4.6.0$ anyrun.sh      ---you can also run this at other directory not limited to
+ echo 'xiaozhan anywhere'
xiaozhan anywhere
windriver@PEK-QCAO1-D2:~/xiaozhan/pexpect-4.6.0$
----------------------- anyrun.sh is at /home/windriver but can run anywhere due to PATH   /home/windriver
windriver@PEK-QCAO1-D2:/usr/bin$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/windriver
windriver@PEK-QCAO1-D2:/usr/bin$ cd /home/windriver/
windriver@PEK-QCAO1-D2:~$ an
anacron    anyrun     anyrun.sh
windriver@PEK-QCAO1-D2:~$ anyrun.sh
+ echo 'xiaozhan anywhere'
xiaozhan anywhere
windriver@PEK-QCAO1-D2:~$ cd ANVL/
windriver@PEK-QCAO1-D2:~/ANVL$ anyrun.sh
+ echo 'xiaozhan anywhere'
xiaozhan anywhere

----------

2.vi /etc/profile
for example
在/etc/profile的最下面添加： PATH=$PATH:/home/windriver

如果修改了/etc/profile，那么编辑结束后执行source profile 或 执行点命令 ./profile, PATH的值就会立即生效了
实测如下：
一个窗口修改/etc/profile，另外一个窗口：
windriver@PEK-QCAO1-D2:~$ cd xiaozhan/
windriver@PEK-QCAO1-D2:~/xiaozhan$ anyrun.sh
+ echo 'xiaozhan anywhere'
xiaozhan anywhere
windriver@PEK-QCAO1-D2:~/xiaozhan$

3.vi ~/.bash_profile
  it should be vi ~/.bashrc    if you are Ubuntu            ----I did not try this method

修改PATH行,把/etc/apache/bin添加进去

这种方法是针对用户起作用的

注意：想改变PATH，必须重新登陆才能生效，以下方法可以简化工作：

如果修改了/etc/profile，那么编辑结束后执行source profile 或 执行点命令 ./profile, PATH的值就会立即生效了。

这个方法的原理就是再执行一次/etc/profile shell脚本，注意如果用sh /etc/profile是不行的，
因为sh是在子shell进程中执行的，即使PATH改变了也不会反应到当前环境中，
但是source是在当前 shell进程中执行的，所以我们能看到PATH的改变。

方法二：
软连接到/bin目录下

2.编译生成可执行文件，my_cmd

3.复制到/bin/目录下

4.创建软连接：

ln -s my_cmd mycmd1

ln -s my_cmd mycmd2

5.在任意目录中，输入my_cmd1，即可打印"hello,world!cmd1."。

实测如下:

windriver@PEK-QCAO1-D2:/bin$ sudo cp /home/windriver/anyrun.sh .        (copy to /bin)

windriver@PEK-QCAO1-D2:/bin$ sudo ln -s anyrun.sh anyrun
windriver@PEK-QCAO1-D2:/bin$

在另外一个窗口：

windriver@PEK-QCAO1-D2:~/xiaozhan$ anyrun
+ echo 'xiaozhan anywhere'
xiaozhan anywhere
windriver@PEK-QCAO1-D2:~/xiaozhan$

++++++++++++++++++++++++++++++++++++++++++++++++++++++++

hostname ----
If you are using CentOS, then you can edit this file to change the hostname:
/etc/sysconfig/network
For my environment:
NETWORKING=yes
NETWORKING_IPV6=yes
HOSTNAME=pek-xli3-d2.wrs.com
NISDOMAIN=swamp

修改了hostname后，如何使其立即生效而不用重启操作系统:
method 1: 使用echo  servername > /proc/sys/kernel/hostname
method 2: sysctl kernel.hostname=servername
method 3: hostname servername

====================================================
Linux系统在向DNS服务器发出域名解析请求之前会查询/etc/hosts文件.if it does not include the hostname,just add it
For my environment:
127.0.0.1   localhost
127.0.0.1   PEK-QCAO1-D2
128.224.160.17 pek-cc-vb01s
128.224.166.46 pek-xli3-d2.wrs.com
# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
================================================
=======scp or rsync  without password========
场景 A主机往B主机传文件
原文链接：https://blog.csdn.net/u010670151/article/details/86649803

1.A主机下执行 (I did not try this)

ssh-keygen -t rsa
默认回车跳过即可
or ssh-keygen   (input 2 enter)  on this server: pek-vx-system1

note: root用户名字有的机器是wrsadmin
这时会在 /root/.ssh/目录下产生两个文件，id_rsa，id_rsa.pub，注意 .ssh/文件为隐藏目录，直接进入即可?

2.将A中生成的id_rsa.pub文件拷贝到B主机的root用户主目录下的.ssh目录下,并且改名为authorized_keys

[xli3@pek-vx-system1 ~]$ ssh-copy-id -i ~/.ssh/id_rsa.pub wrsadmin@128.224.162.222
or you can use scp -r

for example:
wrsadmin@pek-xsun1-d2:~$ cd .ssh/
wrsadmin@pek-xsun1-d2:~/.ssh$ ll
total 16
drwx------  2 wrsadmin wrsadmin 4096 Aug 19 15:50 ./
drwxr-xr-x 25 wrsadmin wrsadmin 4096 Aug 19 15:35 ../
-rw-------  1 wrsadmin wrsadmin  400 Aug 19 15:50 authorized_keys  ----------this is the new key file,name is auto generated
-rw-r--r--  1 wrsadmin wrsadmin 1554 Jul 11 12:22 known_hosts

这时候用rsync或者scp 命令移动文件不需要输入密码

实际测试如下，在我的环境，从pek-vx-system1往128.224.162.222上拷贝文件

[xli3@pek-vx-system1 default]$ scp -r xlnx-zcu102-rev-1.1.dtb  wrsadmin@128.224.162.222:/tftpboot
xlnx-zcu102-rev-1.1.dtb                                                                    100%   19KB  19.3KB/s   00:00

[xli3@pek-vx-system1 default]$ rsync -r xlnx-zcu102-rev-1.1.dtb  wrsadmin@128.224.162.222:/tftpboot
[xli3@pek-vx-system1 default]$
=============================================================
====rsync     without password
https://www.cnblogs.com/felixzh/p/4950049.html

rsync 可以快速同步两个机器上的文件，因为只传输不同的部分，所以当传输很多文件的时候，尤其有些没有改动，
尽量用rsync不要用scp，
=================================
chown can modify the group and user

windriver@PEK-QCAO1-D2:~/test_rsync$ ll a.txt
-rw-rw-r-- 1 windriver windriver 0 Aug 20 14:05 a.txt
windriver@PEK-QCAO1-D2:~/test_rsync$ ls -l
total 0
-rw-rw-r-- 1 windriver windriver 0 Aug 20 14:05 a.txt

The first windriver is the user, and the second windriver is the user group.

-----change the user-----
chown可以更改权限用户
实际测试如下:
sudo chown windriver a.txt
windriver@PEK-QCAO1-D2:~/test_rsync$ sudo chown wrsadmin a.txt
windriver@PEK-QCAO1-D2:~/test_rsync$ ls -l
total 0
-rw-rw-r-- 1 wrsadmin windriver 0 Aug 20 14:05 a.txt
windriver@PEK-QCAO1-D2:~/test_rsync$

chgrp可以更改权限组
sudo chgrp wrsadmin a.txt
实际测试如下:
windriver@PEK-QCAO1-D2:~/test_rsync$ sudo chgrp wrsadmin a.txt
windriver@PEK-QCAO1-D2:~/test_rsync$ ls -l
total 0
-rw-rw-r-- 1 wrsadmin wrsadmin 0 Aug 20 14:05 a.txt
windriver@PEK-QCAO1-D2:~/test_rsync$
==================================================
linux里面用来从网络上下载东西的命令
使用wget -O下载并以不同的文件名保存
使用wget -b后台下载
wget --no-check-certificate  -O test.html https://www.centos.bz/2016/10/download-compile-install-nginx/

==================================
xmanager, to show GUI
export display=192.168.1.1:0.0    the IP of windows machine
==========================================
vi /net/pek-vx-nightly1/buildarea1/pzhang1/jenkinsEnvInjection/vx7_nightly_spin.config
NIGHTLYSPIN=vx20191112061605_vx7-native
lastS=vx20191111061605_vx7-native
LTAFRELEASE=vx7-integration-native
timestamp=20191113170215
PatchBranch=vx7-integration

=================================================
#!/bin/bash
date
#get spin name
source /net/pek-vx-nightly1/buildarea1/pzhang1/jenkinsEnvInjection/vx7_nightly_spin.config
Spin_name=$NIGHTLYSPIN
Branch_name=$LTAFRELEASE
time=$timestamp
patch_branch=$PatchBranch

#Spin_name=vx20191007122204_vx7-SR0630-native
Branch_name=vx7-SR0630-features
#time=20190702170214


installpath=/buildarea2/mw/spin
profile=VxWorks_7_Plus_Platform__Time_Based_BASE

year=`echo $time| cut -c-4`
month=`echo $time| cut -c5-6`
day=`echo $time| cut -c7-8`
week=$year-$month-$day
echo $week
===================================================

Shell获取字符串长度的多种方法总结
方法一】:利用${#str}来获取字符串的长度
windriver@PEK-QCAO1-D2:~/test_rsync$ str="abc"
windriver@PEK-QCAO1-D2:~/test_rsync$ echo ${#str}
3
windriver@PEK-QCAO1-D2:~/test_rsync$

方法2】:利用awk的length方法
str="abc"
echo ${str} | awk '{print length($0)}'
最好用{}来放置变量
     2) 也可以用length($0)来统计文件中每行的长度
for example:
awk '{print length($0)}' /etc/passwd

利用awk的NF项来获取字符串长度:
str="abcd"
echo $str | awk -F "" '{print NF}'
备注: -F为分隔符，NF为域的个数，即单行字符串的长度

【方法四】:利用wc的-L参数来获取字符串的长度
备注: -L参数
1) 对多行文件来说，表示打印最长行的长度！ 82，表示/etc/passwd文件最长行的长度为82
2) 对单行字符串而言，表示当前行字符串的长度！
str="abcd"
echo $str | wc -L

cat /etc/passwd | wc -L

【方法五】:利用wc的-l参数，结合echo -n参数
备注:
1) -c参数: 统计字符的个数
2) -n参数: 去除"\n"换行符，不去除的话，默认带换行符，字符个数就成了7

echo -n $str | wc -l

【方法六】:利用expr的length方法
str="abc"
expr length ${str}

============================================================ configure Ubuntu static ip===============

打开一个终端，在超级用户下使用如下命令(only when configuring static ip address)
current static ip for anvl automation server:
windriver@PEK-QCAO1-D2:~/ANVL/xiaozhan$ vim /etc/network/interfaces
auto lo
iface lo inet loopback

auto eth1
iface eth1 inet static
    address 128.224.163.8
    netmask 255.255.254.0
    gateway 128.224.162.1
    dns-nameservers 128.224.160.11 147.11.100.30 147.11.1.11
    dns-search wrs.com corp.ad.wrs.com windriver.com

然后修改/etc/resolv.conf文件，添加dns命令
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 128.224.160.11
nameserver 147.11.100.30
nameserver 147.11.1.11
search wrs.com corp.ad.wrs.com windriver.com

之后运行

/etc/init.d/networking restart

重启网卡，可得到的ipv4地址，永久性的
====================================================
set the background color as green on linux

Default Foregroung  Red 15 Green 15 Blue 15
Default Backgroung  Red 199 Green 237 Blue 204
Cursor Color        Red 255
===========================================================
how to solve U disk space issue----64G is just showing 70M

https://blog.csdn.net/suiyuehuimou/article/details/82809203
step 1:cmd-----然后输入diskpart，按下回车键；再输入list disk 回车 查看当前有的存储设备，必须记住自己的U盘排序号
step 2:输入select disk X（X是你U盘的排序号），回车后继续输入clean命令进行回车就可以取消u盘原有的分区，
让他重新变成一个未分区的状态；这时u盘的大小已经恢复了，但是u盘是处于未分区状态
step 3:must have this step接着，在我的电脑右键-->管理-->磁盘管理中选择你刚刚的那个U盘，
右键，新建简单卷，大小自己分配成你U盘本身的大小（也就是U盘的最多容量）。
这个相当于重新分区，并且格式化。至此U盘就恢复了原来的容量了
=========================================================================
install python3 in centos:

download package from https://www.python.org/downloads/release/python-375/
3、编译安装

进入解压的python安装包      tar -xvzf Python-3.7.5.tgz

1、[admin@ ~] cd Python-3.6.0a1
2、[admin@ ~] ./configure #有个点

**若执行./configure报错gcc no … **
可执行命令:

 [admin@ ~] yum install gcc  #安装gcc编译环境即可
1
1、[admin@ ~] ./configure #安装完gcc再次执行，如上一步未报错忽略这一步
2、[admin@ ~] make && make install #编译python

4、查看是否成功

[admin@ ~] python3
――――――――――――――――
版权声明：本文为CSDN博主「(.*)释然」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zha6476003/article/details/79282996

安装selenium
安装selenium前先安装setuptools 和pip

请按以下顺序不然可能遇到更多坑

安装setuptools


cd setuptools-38.2.3

python3 setup.py install

如报错：RuntimeError: Compression requires the (missing) zlib module

我们需要在linux中安装zlib-devel包，进行支持。

[admin@ ~] yum install zlib
[admin@ ~] yum install zlib-devel

安装完成后须重新编译安装python
进入我们前面解压的python3.6安装目录执行：

[admin@ ~] make && make install

重新编译后再次安装setuptools

cd setuptools-38.2.3

python3 setup.py install
――――――――――――――――

安装pip
admin@ ~] tar -xvzf pip-9.0.1.tar.gz //解压
[admin@ ~] cd pip-9.0.1 //进入安装文件
[admin@ ~] python3 setup.py build
[admin@ ~] python3 setup.py install //安装pip

报错：

ImportError: No module named '_ssl'
或
ImportError: cannot import name 'HTTPSHandler'
或
pip is configured with locations that require TLS/SSL, however the ssl module in Python is not availa............Could not find a version that satisfies the requirement xxx (from versions: )
No matching distribution found for xxx..

多方查找缺少openssl-devel 我们继续安装

[admin@ ~] yum install openssl-devel

安装完成后须重新编译安装python
进入我们前面解压的python3.6安装目录执行：

[admin@ ~] make && make install

我们使用pip安装selenium：

[admin@ ~] pip3 install -U selenium
#注意linux一般带两个版本python所以这里python3安装的pip要使用pip3命令来使用，如系统只有一个版本python可忽略直接使用pip命令

=========================set python environment variable========================
这是在python3安装目录下运行的，然后还将其添加到PATH，查询PATH echo $PATH

windriver@PEK-QCAO1-D2:/usr/bin$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/windriver

使用如下命令：

ln -s /usr/local/python32/bin/python3 /usr/bin/python（如果ln -s /usr/local/python32/bin/python3 /usr/bin/python3 则python还是启动2.7 python3 则启动3.*版）

这里我用的是后者。

接下来在随便路径都可以使用python3命令了。


=======================================执行linux命令或者脚本，抓取输出信息==========
./ANVL.py -t %s -c all -s %s -l %s -v %s | tee anvl.log 2>&1

2>&1，意思是错误输出等同于标准输出。所以使得./test.sh >test.log，可以把标准输出和错误输出全部导入日志test.log里。
注意：2>&1，中间不能有空格。
注意：2>&1，必须写在最后，否则会失去原有意义








